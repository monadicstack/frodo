// Code generated by Frodo from scores/score_service.go - DO NOT EDIT
//
//   https://github.com/monadicstack/frodo
//
package scores

import (
	"context"
	"fmt"

	"github.com/monadicstack/frodo/example/multiservice/scores"
	"github.com/monadicstack/frodo/rpc"
)

// NewScoreServiceClient creates an RPC client that conforms to the ScoreService interface, but delegates
// work to remote instances. You must supply the base address of the remote service gateway instance or
// the load balancer for that service.
// ScoreService is a shared leaderboard service that tracks the high scores that people have
// achieved while playing various games.
func NewScoreServiceClient(address string, options ...rpc.ClientOption) *ScoreServiceClient {
	rpcClient := rpc.NewClient("ScoreService", address, options...)
	rpcClient.PathPrefix = "/v2"
	return &ScoreServiceClient{Client: rpcClient}
}

// ScoreServiceClient manages all interaction w/ a remote ScoreService instance by letting you invoke functions
// on this instance as if you were doing it locally (hence... RPC client). You shouldn't instantiate this
// manually. Instead, you should utilize the NewScoreServiceClient() function to properly set this up.
type ScoreServiceClient struct {
	rpc.Client
}

// HighScoresForGame fetches the top "N" high scores achieved by any player
// for the specified game. If you don't specify the HowMany value, this will default
// to returning the top 5 scores.
//
// Frodo Notes: The request has 2 attributes. The GameID field will be populated via the
// path parameters, but HowMany will be specified via the query string. The auto-generated
// clients will do this by default under the hood, but if you use curl/Postman, that's how
// you would supply that (e.g. "/v2/game/2/highscore?howMany=3" for the top 3).
func (client *ScoreServiceClient) HighScoresForGame(ctx context.Context, request *scores.HighScoresForGameRequest) (*scores.HighScoresForGameResponse, error) {
	if ctx == nil {
		return nil, fmt.Errorf("precondition failed: nil context")
	}
	if request == nil {
		return nil, fmt.Errorf("precondition failed: nil request")
	}

	response := &scores.HighScoresForGameResponse{}
	err := client.Invoke(ctx, "GET", "/game/:GameID/highscore", request, response)
	return response, err
}

// NewHighScore captures a player's high score for the given game.
func (client *ScoreServiceClient) NewHighScore(ctx context.Context, request *scores.NewHighScoreRequest) (*scores.NewHighScoreResponse, error) {
	if ctx == nil {
		return nil, fmt.Errorf("precondition failed: nil context")
	}
	if request == nil {
		return nil, fmt.Errorf("precondition failed: nil request")
	}

	response := &scores.NewHighScoreResponse{}
	err := client.Invoke(ctx, "POST", "/game/:GameID/highscore", request, response)
	return response, err
}

// ScoreServiceProxy fully implements the ScoreService interface, but delegates all operations to a "real"
// instance of the service. You can embed this type in a struct of your choice so you can "override" or
// decorate operations as you see fit. Any operations on ScoreService that you don't explicitly define will
// simply delegate to the default implementation of the underlying 'Service' value.
//
// Since you have access to the underlying service, you are able to both implement custom handling logic AND
// call the "real" implementation, so this can be used as special middleware that applies to only certain operations.
type ScoreServiceProxy struct {
	Service scores.ScoreService
}

func (proxy *ScoreServiceProxy) HighScoresForGame(ctx context.Context, request *scores.HighScoresForGameRequest) (*scores.HighScoresForGameResponse, error) {
	return proxy.Service.HighScoresForGame(ctx, request)
}

func (proxy *ScoreServiceProxy) NewHighScore(ctx context.Context, request *scores.NewHighScoreRequest) (*scores.NewHighScoreResponse, error) {
	return proxy.Service.NewHighScore(ctx, request)
}
