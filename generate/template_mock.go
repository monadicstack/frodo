package generate

// TemplateMockGo is the text template for a service's testing mock struct. It implements all of the
// interface's functions while providing easily configurable behaviors for any of the functions.
var TemplateMockGo = parseArtifactTemplate("mock.go", `// Code generated by Frodo from {{ .Path }} - DO NOT EDIT
//
//   https://github.com/monadicstack/frodo
//
package {{ .OutputPackage.Name }}

import (
	"context"
	"fmt"
	"time"

	"{{ .Package.Import }}"
)

{{ $ctx := . }}
{{ range $service := .Services }}
// Mock{{ .Name }} allows you to program behaviors into a mock instance of {{ .Name }}. You supply
// dynamic functions named "XxxFunc" to provide the custom behavior; so if your service has a function
// called 'CreateUser', you supply a function for 'CreateUserFunc'.
//
// You do not need to supply behaviors for every single service function; just the ones you plan to
// test. If you do invoke a function without a programmed behavior, it will just return an error
// with a message indicating that it wasn't implemented.
type Mock{{ .Name }} struct {
	{{ range $function := .Functions -}}
	  {{ .Name }}Func func(context.Context, *{{ $ctx.Package.Name }}.{{ .Request.Name }}) (*{{ $ctx.Package.Name }}.{{ .Response.Name }}, error)
	{{ end }}
	Calls struct {
		{{ range $function := .Functions -}}
		  {{ .Name }} calls{{ $service.Name }}{{ .Name }}
		{{ end }}
	}
}

{{ range $function := .Functions }}
/* ---- {{ $service.Name }}.{{ .Name }} Mock Support For  ---- */

func (mock *Mock{{ $service.Name }}) {{ .Name }}(ctx context.Context, request *{{ $ctx.Package.Name }}.{{ .Request.Name }}) (*{{ $ctx.Package.Name }}.{{ .Response.Name }}, error) {
	mock.Calls.{{ .Name }} = mock.Calls.{{ .Name }}.invoked(*request) 
	if mock.{{ .Name }}Func == nil {
		return nil, fmt.Errorf("{{ $service.Name }}.{{ .Name }} not implemented")
	}
	response, err := mock.{{ .Name }}Func(ctx, request)
	return response, err
}

{{ $callsType := (print "calls" $service.Name .Name) }} 
{{ $callType := (print "call" $service.Name .Name) }} 
{{ $requestType := (print $ctx.Package.Name "." .Request.Name) }}
type {{ $callType }} struct {
	Time    time.Time
	Request {{ $requestType }}
}

type {{ $callsType }} []{{ $callType }}

func (calls {{ $callsType }}) invoked(request {{ $requestType }}) {{ $callsType }} {
	return append(calls, {{ $callType }}{Time: time.Now(), Request: request})
}

// Times return the total number of times that {{ .Name }} was invoked with any request arguments.
func (calls {{ $callsType }}) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that {{ .Name }} was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls {{ $callsType }}) TimesFor(request {{ $requestType }}) int {
	return calls.TimesMatching(func(actual {{ $requestType }}) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that {{ .Name }} was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls {{ $callsType }}) TimesMatching(pred func({{ $requestType }}) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}
{{ end }}
{{ end }}
`)

/*

func (calls calls{{ $service.Name }}{{ .Name }}) Invoked(request interface{}) call{{ $service.Name }}{{ .Name }} {
	return append(history, callHistoryEntry{
		Time:    time.Now(),
		Request: request,
	})
}

func (history invocationHistory) Times() int {
	return len(history)
}

func (history invocationHistory) TimesFor(request interface{}) int {
	request = reflect.Indirect(reflect.ValueOf(request)).Interface()

	count := 0
	for _, entry := range history {
		if entry.Request == request {
			count++
		}
	}
	return count
}

type invocationHistoryEntry struct {
	Time    time.Time
	Request interface{}
}

*/
