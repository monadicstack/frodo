// Code generated by Frodo from {{ .Path }} - DO NOT EDIT
//
//   https://github.com/monadicstack/frodo
//
import 'dart:async';
import 'dart:convert';
import 'dart:io';

{{- $serviceName := .Service.Name }}
{{- $clientName := (print .Service.Name "Client")}}
{{- $exceptionName :=  (print .Service.Name "Exception")}}

class {{ $clientName }} {
  static const String pathPrefix = '{{ .Service.Gateway.PathPrefix }}';

  final String baseURL;
  String authorization;
  HttpClient httpClient = HttpClient();

  {{ $clientName }}(this.baseURL, {
      this.authorization = '',
  });

  {{ range .Service.Functions }}
  {{- if .Documentation.NotEmpty }}{{- range .Documentation }}
  /// {{ . }}
  {{- end }}{{- end }}
  Future<{{ .Response.Name }}> {{ .Name }}({{ .Request.Name }} serviceRequest, {String authorization = ''}) async {
    var requestJson = serviceRequest.toJson();
    var method = '{{ .Gateway.Method }}';
    var route = '{{ .Gateway.Path }}';
    var url = _joinUrl([baseURL, pathPrefix, _buildRequestPath(method, route, requestJson)]);

    var httpRequest = await httpClient.openUrl(method, Uri.parse(url));
    httpRequest.headers.set('Accept', 'application/json');
    httpRequest.headers.set('Authorization', _authorize(authorization));
    httpRequest.headers.set('Content-Type', 'application/json');
    {{ if .Gateway.SupportsBody }}httpRequest.write(jsonEncode(requestJson));{{ end }}

    var httpResponse = await httpRequest.close();
    return _handleResponse(httpResponse, (json) => {{ .Response.Name }}.fromJson(json));
  }
  {{ end }}

  String _buildRequestPath(String method, String route, Map<String, dynamic> requestJson) {
    String stringify(Map<String, dynamic> json, String key) {
      return Uri.encodeComponent(json[key]?.toString() ?? '');
    }
    String stringifyAndRemove(Map<String, dynamic> json, String key) {
      return Uri.encodeComponent(json.remove(key)?.toString() ?? '');
    }

    // Since we're embedding values in a path or query string, we need to flatten "{a: {b: {c: 4}}}"
    // down to "a.b.c=4" for it to fit nicely into our URL-based binding.
    requestJson = _flattenJson(requestJson);

    var resolvedPath = route
      .split('/')
      .map((s) => s.startsWith(':') ? stringifyAndRemove(requestJson, s.substring(1)) : s)
      .join('/');

    // These encode the data in the body, so no need to shove it in the query string.
    if (method == 'POST' || method == 'PUT' || method == 'PATCH') {
      return resolvedPath;
    }

    // GET/DELETE/etc will pass all values through the query string.
    var queryValues = requestJson.keys
      .map((key) => key + '=' + stringify(requestJson, key))
      .join('&');

    return resolvedPath + '?' + queryValues;
  }

  Future<T> _handleResponse<T>(HttpClientResponse httpResponse, T Function(Map<String, dynamic>) factory) async {
    var bodyCompleter = new Completer<String>();
    httpResponse.transform(utf8.decoder).listen(bodyCompleter.complete);
    var bodyText = await bodyCompleter.future;

    if (httpResponse.statusCode >= 400) {
      throw new {{ $exceptionName }}(httpResponse.statusCode, _parseErrorMessage(bodyText));
    }

    return factory(jsonDecode(bodyText));
  }

  String _parseErrorMessage(String bodyText) {
    try {
      Map<String, dynamic> json = jsonDecode(bodyText);
      return json['message'] ?? json['error'] ?? bodyText;
    }
    catch (_) {
      return bodyText;
    }
  }

  String _authorize(String callAuthorization) {
    return callAuthorization.trim().isNotEmpty
      ? callAuthorization
      : authorization;
  }

  String _joinUrl(List<String> segments) {
    String stripLeadingSlash(String s) {
      while (s.startsWith('/')) {
        s = s.substring(1);
      }
      return s;
    }
    String stripTrailingSlash(String s) {
      while (s.endsWith('/')) {
        s = s.substring(0, s.length - 1);
      }
      return s;
    }
    bool notEmpty(String s) {
      return s.isNotEmpty;
    }

    return segments
        .map(stripLeadingSlash)
        .map(stripTrailingSlash)
        .where(notEmpty)
        .join('/');
  }

  Map<String, dynamic> _flattenJson(Map<String, dynamic> json) {
    // Adds the given json map entry to the accumulator map. The 'path' contains
    // the period-delimited path for all parent objects we've recurred down from.
    void flattenEntry(String path, String key, dynamic value, Map<String, dynamic> accum) {
      if (value == null) {
        return;
      }

      path = path == '' ? key : '$path.$key';
      if (value is Map<String, dynamic>) {
        value.keys.forEach((key) => flattenEntry(path, key, value[key], accum));
        return;
      }
      accum[path] = value;
    }

    Map<String, dynamic> result = Map<String, dynamic>();
    json.keys.forEach((key) => flattenEntry("", key, json[key], result));
    return result;
  }
}

class {{ $exceptionName }} implements Exception {
    int status;
    String message;

    {{ $exceptionName }}(this.status, this.message);
}

{{ range .Types.NonBasicTypes }}
{{- $typeName := .Name | CleanTypeNameUpper }}
{{- if .Documentation.NotEmpty }}{{- range .Documentation }}
/// {{ . }}
{{- end }}{{- end }}
class {{ $typeName }} implements {{ $serviceName }}ModelJSON { {{ range .Fields }}
  {{ .Type | DartType }}? {{ .Binding.Name }};
  {{- end }}

  {{ $typeName }}({ {{ range .Fields }}
    this.{{ .Binding.Name }},
  {{- end }}
  });

  {{ $typeName }}.fromJson(Map<String, dynamic> json) { {{ range .Fields -}}
    {{ $fieldName := .Binding.Name }}
    {{- if .Type.PrimitiveLike }}
    {{ $fieldName }} = json['{{ $fieldName }}'];
    {{- else if .Type.ObjectLike }}
    {{ $fieldName }} = {{ .Type.Name | CleanTypeNameUpper }}.fromJson(json['{{ $fieldName }}']);
    {{- else if .Type.SliceLike }}
    {{- if .Type.Elem.PrimitiveLike }}
    {{ $fieldName }} = _map(json['{{ $fieldName }}'], (x) => x);
    {{- else if .Type.Elem.ObjectLike }}
    {{ $fieldName }} = _map(json['{{ $fieldName }}'], (x) => {{ .Type.Name | CleanTypeNameUpper }}.fromJson(x));
    {{- end }}
    {{- end }}
    {{- end }}
  }

  Map<String, dynamic> toJson() {
    return { {{ range .Fields -}}
      {{ $fieldName := .Binding.Name }}
      {{- if .Type.PrimitiveLike }}
      '{{ $fieldName }}': {{ $fieldName }},
      {{- else if .Type.ObjectLike }}
      '{{ $fieldName }}': {{ $fieldName }}?.toJson(),
      {{- else if .Type.SliceLike }}
      {{- if .Type.Elem.PrimitiveLike }}
      '{{ $fieldName }}': _map({{ $fieldName }}, (x) => x),
      {{- else if .Type.Elem.ObjectLike }}
      '{{ $fieldName }}': _map({{ $fieldName }}, (x) => x?.toJson()),
      {{- end }}
      {{- end }}
      {{- end }}
    };
  }
}
{{ end }}

class {{$serviceName}}ModelJSON {
  Map<String, dynamic> toJson() {
    throw new Exception('toJson not implemented');
  }
}

        List<T>? _map<T>(List<dynamic>? jsonList, T Function(dynamic) mapping) {
  return jsonList == null ? null : jsonList.map(mapping).toList();
}
