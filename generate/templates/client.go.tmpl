// Code generated by Frodo - DO NOT EDIT.
//
//   Timestamp: {{ .TimestampString }}
//   Source:    {{ .Path }}
//   Generator: https://github.com/monadicstack/frodo
//
package {{ .OutputPackage.Name }}

import (
	"context"
	"fmt"

	"github.com/monadicstack/frodo/rpc"
	"{{ .InputPackage.Import }}"
)

{{ $ctx := . }}
{{ $serviceName := .Service.Name }}
{{ $clientName := (print $serviceName "Client") }}

// New{{ $clientName }} creates an RPC client that conforms to the {{ $serviceName }} interface, but delegates
// work to remote instances. You must supply the base address of the remote service gateway instance or
// the load balancer for that service. {{ if .Service.Documentation.NotEmpty }}
// {{ range .Service.Documentation }}
// {{ . }}{{ end }}{{ end }}
func New{{ $clientName }}(address string, options ...rpc.ClientOption) *{{ $clientName }} {
	rpcClient := rpc.NewClient("{{ $serviceName }}", address, options...)
	rpcClient.PathPrefix = "{{ .Service.Gateway.PathPrefix }}"
	return &{{ $clientName }}{Client: rpcClient}
}

// {{ $clientName }} manages all interaction w/ a remote {{ $serviceName }} instance by letting you invoke functions
// on this instance as if you were doing it locally (hence... RPC client). You shouldn't instantiate this
// manually. Instead, you should utilize the New{{ $clientName }}() function to properly set this up.
type {{ $clientName }} struct {
	rpc.Client
}

{{ range .Service.Functions }}
{{ range .Documentation }}
// {{ . }}{{ end }}
func (client *{{ $clientName }}) {{ .Name }} (ctx context.Context, request *{{ $ctx.InputPackage.Name }}.{{ .Request.Name | NoPointer }}) (*{{ $ctx.InputPackage.Name }}.{{ .Response.Name | NoPointer }}, error) {
	if ctx == nil {
		return nil, fmt.Errorf("precondition failed: nil context")
	}
	if request == nil {
		return nil, fmt.Errorf("precondition failed: nil request")
	}

	response := &{{ $ctx.InputPackage.Name }}.{{ .Response.Name }}{}
	err := client.Invoke(ctx, "{{ .Gateway.Method }}", "{{ .Gateway.Path }}", request, response)
	return response, err
}
{{ end }}

// {{ $serviceName }}Proxy fully implements the {{ $serviceName }} interface, but delegates all operations to a "real"
// instance of the service. You can embed this type in a struct of your choice so you can "override" or
// decorate operations as you see fit. Any operations on {{ $serviceName }} that you don't explicitly define will
// simply delegate to the default implementation of the underlying 'Service' value.
//
// Since you have access to the underlying service, you are able to both implement custom handling logic AND
// call the "real" implementation, so this can be used as special middleware that applies to only certain operations.
type {{ $serviceName }}Proxy struct {
	Service {{ $ctx.InputPackage.Name }}.{{ $serviceName }}
}

{{ range .Service.Functions }}
func (proxy *{{ $serviceName }}Proxy) {{ .Name }} (ctx context.Context, request *{{ $ctx.InputPackage.Name }}.{{ .Request.Name }}) (*{{ $ctx.InputPackage.Name }}.{{ .Response.Name }}, error) {
	return proxy.Service.{{ .Name }}(ctx, request)
}
{{ end }}
