// Code generated by Frodo - DO NOT EDIT.
//
//   Timestamp: {{ .TimestampString }}
//   Source:    {{ .Path }}
//   Generator: https://github.com/monadicstack/frodo
//
package {{ .OutputPackage.Name }}

import (
	"context"
	"fmt"
	"time"

	"{{.InputPackage.Import }}"
)

{{ $ctx := . }}
{{ $serviceName := .Service.Name }}
{{ $mockName := (print "Mock" $serviceName) }}
// {{ $mockName }} allows you to program behaviors into a mock instance of {{ $serviceName }}. You supply
// dynamic functions named "XxxFunc" to provide the custom behavior; so if your service has a function
// called 'CreateUser', you supply a function for 'CreateUserFunc'.
//
// You do not need to supply behaviors for every single service function; just the ones you plan to
// test. If you do invoke a function without a programmed behavior, it will just return an error
// with a message indicating that it wasn't implemented.
type {{ $mockName }} struct {
	{{ range $function := .Service.Functions -}}
	  {{ .Name }}Func func(context.Context, *{{ $ctx.InputPackage.Name }}.{{ .Request.Name }}) (*{{ $ctx.InputPackage.Name }}.{{ .Response.Name }}, error)
	{{ end }}
	Calls struct {
		{{ range $function := .Service.Functions -}}
		  {{ .Name }} calls{{ $serviceName }}{{ .Name }}
		{{ end }}
	}
}

{{ range $function := .Service.Functions }}
/* ---- {{ $serviceName }}.{{ .Name }} Mock Support For  ---- */

func (mock *{{ $mockName }}) {{ .Name }}(ctx context.Context, request *{{ $ctx.InputPackage.Name }}.{{ .Request.Name }}) (*{{ $ctx.InputPackage.Name }}.{{ .Response.Name }}, error) {
	mock.Calls.{{ .Name }} = mock.Calls.{{ .Name }}.invoked(*request)
	if mock.{{ .Name }}Func == nil {
		return nil, fmt.Errorf("{{ $serviceName }}.{{ .Name }} not implemented")
	}
	response, err := mock.{{ .Name }}Func(ctx, request)
	return response, err
}

{{ $callsType := (print "calls" $serviceName .Name) }}
{{ $callType := (print "call" $serviceName .Name) }}
{{ $requestType := (print $ctx.InputPackage.Name "." .Request.Name) }}
type {{ $callType }} struct {
	Time    time.Time
	Request {{ $requestType }}
}

type {{ $callsType }} []{{ $callType }}

func (calls {{ $callsType }}) invoked(request {{ $requestType }}) {{ $callsType }} {
	return append(calls, {{ $callType }}{Time: time.Now(), Request: request})
}

// Times return the total number of times that {{ .Name }} was invoked with any request arguments.
func (calls {{ $callsType }}) Times() int {
	return len(calls)
}

// TimesFor return the total number of times that {{ .Name }} was invoked with the specific input. Equality
// is determined using == on this 'request' param and the de-referenced one used in the invocation, so
// we'll only county times for those with structural equality.
func (calls {{ $callsType }}) TimesFor(request {{ $requestType }}) int {
	return calls.TimesMatching(func(actual {{ $requestType }}) bool {
		return actual == request
	})
}

// TimesMatching return the total number of times that {{ .Name }} was invoked with any
// input that returns true when fed to your predicate function. It's a way to filter by
// requests that meet some requirement more complex than equality (like TimesFor uses).
func (calls {{ $callsType }}) TimesMatching(pred func({{ $requestType }}) bool) int {
	count := 0
	for _, call := range calls {
		if pred(call.Request) {
			count++
		}
	}
	return count
}
{{ end }}

