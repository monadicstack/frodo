// Code generated by Frodo - DO NOT EDIT.
//
//   Timestamp: {{ .TimestampString }}
//   Source:    {{ .Path }}
//   Generator: https://github.com/monadicstack/frodo
//
/* global fetch,module,window */
'use strict';

/**
 * Exposes all of the standard operations for the remote {{ .Service.Name }} service. These RPC calls
 * will be sent over http(s) to the backend service instances. {{ range .Service.Documentation }}
 * {{ . }}{{end}}
 */
class {{ .Service.Name }}Client {
    _baseURL;
    _fetch;
    _authorization;

    /**
     * @param {string} baseURL The protocol/host/port used by all API/service
     *     calls (e.g. "https://some-server:9000")
     * @param {object} [options]
     * @param {fetch|*} [options.fetch] Provide a custom implementation for the 'fetch' API. Not
     *     necessary if running in browser.
     * @param {string} [options.authorization] Use these credentials in the HTTP Authorization header
     *      for every request. Only use the client-level authorization when all requests to the
     *      service should have the same credentials. If you allow multiple users in your system,
     *      leave this blank and use the authorization option on each request.
     */
    constructor(baseURL, {fetch, authorization} = {}) {
        this._baseURL = trimSlashes(trimSlashes(baseURL) + '/' + trimSlashes('{{ .Service.Gateway.PathPrefix}}'));
        this._fetch = fetch || defaultFetch();
        this._authorization = authorization || '';
    }

    {{ range .Service.Functions }}
    /**{{ range $doc := .Documentation }}
     * {{ . }} {{ end }}
     *
     * @param { {{ .Request.Name }} } serviceRequest The input parameters
     * @param {object} [options]
     * @param { string } [options.authorization] The HTTP Authorization header value to include
     *     in the request. This will override any authorization you might have applied when
     *     constructing this client. Use this in multi-tenant situations where multiple users
     *     might utilize this service.
     * @returns {Promise<{{ .Response.Name }}>} The JSON-encoded return value of the operation.
     */
    async {{ .Name }}(serviceRequest, {authorization} = {}) {
        if (!serviceRequest) {
            throw new Error('precondition failed: empty request');
        }

        const method = '{{ .Gateway.Method }}';
        const route = '{{ .Gateway.Path }}';
        const url = this._baseURL + '/' + buildRequestPath(method, route, serviceRequest);
        const fetchOptions = {
            method: '{{ .Gateway.Method }}',
            headers: {
                'Authorization': authorization || this._authorization,
                'Accept': 'application/json,*/*',
                'Content-Type': 'application/json; charset=utf-8',
            },
            {{ if .Gateway.SupportsBody }}body: JSON.stringify(serviceRequest),{{ end }}
        };

        const response = await this._fetch(url, fetchOptions);
        {{- if .Response.Implements.ContentWriter }}
        return handleResponseRaw(response);
        {{- else }}
        return handleResponseJSON(response);
        {{- end }}
    }
    {{ end }}
}

/**
 * Fills in a router path pattern such as "/user/:id", with the appropriate attribute from
 * the 'serviceRequest' instance.
 *
 * @param {string} method The HTTP method for this request (determines if we include a query string)
 * @param {string} path The path pattern to populate w/ runtime values (e.g. "/user/:id")
 * @param {Object} serviceRequest The input struct for the service call
 * @returns {string} The fully-populate URL path (e.g. "/user/aCx31s")
 */
function buildRequestPath(method, path, serviceRequest) {
    const pathSegments = path.split("/").map(segment => {
        return segment.startsWith(":")
            ? attributeValue(serviceRequest, segment.substring(1))
            : segment;
    });
    const resolvedPath = trimSlashes(pathSegments.join("/"));

    // PUT/POST/PATCH encode the data in the body, so no need to shove it in the query string.
    if (supportsBody(method)) {
        return resolvedPath;
    }

    // GET/DELETE/etc will pass all values through the query string.
    const queryValues = Object.getOwnPropertyNames(serviceRequest)
        .map(attr => attr + '=' + encodeURLParam(serviceRequest[attr]))
        .join('&');

    return resolvedPath + '?' + queryValues;
}

/**
 * Selectively encodes a URL param to be used in the URL path or query string.
 *
 * @param {*} value The value to encode in the URL
 * @returns {string}
 */
function encodeURLParam(value) {
    if (value === null) {
        return '';
    }
    switch (typeof value) {
    case 'undefined':
        return '';
    case 'string':
    case 'number':
    case 'boolean':
        return encodeURIComponent(value);
    case 'function':
        return encodeURLParam(value());
    default:
        const valueJSON = JSON.stringify(value);
        return encodeURIComponent(valueJSON);
    }
}

/**
 * Given a struct-style object, return the values of the matching attribute. This is meant
 * to match the server's loose matching where the attribute name "ID" will match the
 * field "id".
 *
 * @param {Object} struct The data structure whose value you're trying to peel off.
 * @param {string} attributeName The name of the input value you're trying to send
 * @returns {*}
 */
function attributeValue(struct, attributeName) {
    const normalized = attributeName.toLowerCase();
    for (const key in struct) {
        if (key.toLowerCase() === normalized) {
            return encodeURLParam(struct[key]);
        }
    }
    return null;
}


/**
 * Accepts the full response data and the request's promise resolve/reject and determines
 * which to invoke. This will also JSON-unmarshal the response data if need be.
 */
async function handleResponseJSON(response) {
    if (response.status >= 400) {
        throw await newError(response);
    }
    return await response.json();
}

/**
 * Accepts the full response data and the request's promise resolve/reject and determines
 * which to invoke. This assumes that you want the raw bytes as a blob from the HTTP response
 * rather than treating it like JSON. This will also capture the Content-Type value as well as
 * the "filename" from the Content-Disposition if it's set to "attachment".
 *
 * @returns { {content: Blob, contentType: string, contentFileName: string} }
 */
async function handleResponseRaw(response) {
    if (response.status >= 400) {
        throw await newError(response);
    }
    const content = await response.blob();
    const contentType = response.headers.get('content-type') || 'application/octet-stream';
    const contentFileName = dispositionFileName(response.headers.get('content-disposition'));
    return {
        Content: content,
        ContentType: contentType,
        ContentFileName: contentFileName,
    }
}

/**
 * Creates a new GatewayError with all of the meaningful status/message info extracted
 * from the HTTP response.
 *
 * @returns {Promise<GatewayError>}
 */
async function newError(response) {
    const responseValue = isJSON(response)
        ? await response.json()
        : await response.text();

    throw new GatewayError(response.status, parseErrorMessage(responseValue));
}

/**
 * Parses a value from the Content-Disposition header to extract just the filename attribute.
 *
 * @param {string} contentDisposition
 * @returns {string}
 */
function dispositionFileName(contentDisposition = '') {
    const fileNameAttrPos = contentDisposition.indexOf('filename=');
    if (fileNameAttrPos < 0) {
        return '';
    }

    let fileName = contentDisposition.substring(fileNameAttrPos + 9);
    fileName = fileName.startsWith('"') ? fileName.substring(1) : fileName;
    fileName = fileName.endsWith('"') ? fileName.substring(0, fileName.length - 1) : fileName;
    fileName = fileName.replace(/\\"/g, '"');
    return fileName;
}

/**
 * Determines whether or not the response has a content type of JSON.
 */
function isJSON(response) {
    const contentType = response.headers.get('content-type');
    return contentType && contentType.toLowerCase().startsWith('application/json');
}

/**
* Looks at the response value and attempts to peel off an error message from it using the standard
* error JSON structures used by frodo gateways.
*
* @param {*} err The error whose raw message you're trying to extract.
* @returns {string}
*/
function parseErrorMessage(err) {
    if (typeof err === 'string') {
        return err;
    }
    if (typeof err.message !== 'undefined') {
        return err.message;
    }
    if (typeof err.error !== 'undefined') {
        return err.error;
    }
    return JSON.stringify(err);
}

/**
 * Does the HTTP method given support supplying data in the body of the request? For instance
 * this is true for POST but not for GET.
 *
 * @param {string} method The HTTP method that you are processing (e.g. "GET", "POST", etc)
 * @returns {boolean}
 */
function supportsBody(method) {
    return method === 'POST' || method === 'PUT' || method === 'PATCH';
}

/**
 * Removes all leading/trailing slashes from the given URL segment.
 *
 * @param {string} value The URL path segment to clean up.
 * @returns {string}
 */
function trimSlashes(value) {
    if (!value) {
        return "";
    }
    while (value.startsWith("/")) {
        value = value.substring(1);
    }
    while (value.endsWith("/")) {
        value = value.substring(0, value.length - 1);
    }
    return value;
}

/**
* When you don't supply your own Fetch implementation, this will attempt to use
* any globally defined ones (typically for use in the browser).
*
* @returns {fetch}
*/
function defaultFetch() {
    if (typeof fetch === 'undefined') {
        throw new Error('no global fetch found - if using node, install/import node-fetch');
    }

    const runningInBrowser = typeof window !== 'undefined';
    return runningInBrowser ? fetch.bind(window) : fetch;
}

/**
* GatewayError is a rich error type that encapsulates a failure generated by the remote gateway.
* It captures the server's error message as well as HTTP status so you can properly handle the
* result in your consumer code.
*/
class GatewayError {
    /**
    * The HTTP 4XX/5XX status code of the failure.
    *
    * @type {number}
    */
    status;

    /**
    * The user-facing message that the server generated for the error.
    *
    * @type {string}
    */
    message;

    constructor(status, message) {
        this.status = status;
        this.message = message;
    }

    toString() {
        return this.status + ": " + this.message;
    }
}

{{ range .Types.NonBasicTypes }}
/**
 * @typedef { {{ . | JSTypedefType }} } {{ .Name | JoinPackageName | NoPointer }}{{ range .Fields }}
 * @property { {{ .Type | JSPropertyType }} } [{{ .Binding.Name }}]{{ end }}
*/
{{- end }}

module.exports = {
    {{ .Service.Name }}Client,
};
