package generate

// TemplateClientJS is the text template that generates a JavaScript/Node based client for interacting
// with the remote service over RPC/REST.
var TemplateClientJS = parseArtifactTemplate("client.js", `// !!!!!!! DO NOT EDIT !!!!!!!
// Auto-generated by Frodo from service definition {{ .Path }}
// !!!!!!! DO NOT EDIT !!!!!!!
'use strict';

const defaultFetch = fetch.bind(window);

{{ range $service := .Services }}/**
 * Exposes all of the standard operations for the remote {{ .Name }} service. These RPC calls will be
 * sent over http(s) to the backend service instances. {{ range .Documentation }}
 * {{ . }}{{end}}
 */
class {{ .Name }}Client {
    _baseURL;
    _fetch;

    constructor(baseURL, {fetch} = {}) {
        this._baseURL = trimSlashes(trimSlashes(baseURL) + '/' + trimSlashes('{{ .HTTPPathPrefix}}'));
        this._fetch = fetch || defaultFetch;
    }

    {{ range .Methods }}
    /**{{ range $doc := .Documentation }}
     * {{ . }} {{ end }}
     *
     * @param { {{ .Request.Name }} } serviceRequest The input parameters
     * @returns {Promise<{{ .Response.Name }}>} The JSON-encoded return value of the operation.
     */
    async {{ .Name }}(serviceRequest) {
        const url = this._baseURL + buildRequestPath('{{ .HTTPMethod }}', '{{ .HTTPPath }}', serviceRequest);
        {{ if .HTTPMethod | HTTPMethodSupportsBody }}const bodyJSON = JSON.stringify(serviceRequest);{{ end }}

        const options = {
            method: '{{ .HTTPMethod }}',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json; charset=utf-8',
            },
            {{ if .HTTPMethod | HTTPMethodSupportsBody }}body: bodyJSON,{{ end }}
        };
        const response = await this._fetch(url, options);
        return handleResponse(response);
    }
    {{ end }}
}
{{ end }}

/**
 * Fills in a router path pattern such as "/user/:id", with the appropriate attribute from
 * the 'serviceRequest' instance.
 *
 * @param {string} method The HTTP method for this request (determines if we include a query string)
 * @param {string} path The path pattern to populate w/ runtime values (e.g. "/user/:id")
 * @param {Object} serviceRequest The input struct for the service call
 * @returns {string} The fully-populate URL path (e.g. "/user/aCx31s")
 */
function buildRequestPath(method, path, serviceRequest) {
    const pathSegments = path.split("/").map(segment => {
        return segment.startsWith(":")
            ? attributeValue(serviceRequest, segment.substring(1))
            : segment;
    });
    const resolvedPath = pathSegments.join("/");

    // PUT/POST/PATCH encode the data in the body, so no need to shove it in the query string.
    if (supportsBody(method)) {
        return resolvedPath;
    }

    // GET/DELETE/etc will pass all values through the query string.
    const queryValues = Object.getOwnPropertyNames(serviceRequest)
        .map(attr => attr + '=' + encodeURLParam(serviceRequest[attr]))
        .join('&');

    return resolvedPath + '?' + queryValues;
}

/**
 * Selectively encodes a URL param to be used in the URL path or query string.
 *
 * @param {*} value The value to encode in the URL
 * @returns {string}
 */
function encodeURLParam(value) {
    if (value === null) {
        return '';
    }
    switch (typeof value) {
    case 'undefined':
        return '';
    case 'string':
    case 'number':
    case 'boolean':
        return encodeURIComponent(value);
    case 'function':
        return encodeURLParam(value());
    default:
        const valueJSON = JSON.stringify(value);
        return encodeURIComponent(valueJSON);
    }
}

/**
 * Given a struct-style object, return the values of the matching attribute. This is meant
 * to match the server's loose matching where the attribute name "ID" will match the
 * field "id".
 *
 * @param {Object} struct The data structure whose value you're trying to peel off.
 * @param {string} attributeName The name of the input value you're trying to send
 * @returns {*}
 */
function attributeValue(struct, attributeName) {
    const normalized = attributeName.toLowerCase();
    for (const key in struct) {
        if (key.toLowerCase() === normalized) {
            return encodeURLParam(struct[key]);
        }
    }
    return null;
}

/**
 * Accepts the full response data and the request's promise resolve/reject and determines
 * which to invoke. This will also JSON-unmarshal the response data if need be.
 */
function handleResponse(response) {
    const contentType = response.headers.get('content-type');
    const responseValue = !contentType || contentType.startsWith('application/json')
        ? response.json()
        : response.text();

    if (response.status >= 400) {
        throw new Error(responseValue);
    }
    return responseValue;
}

/**
 * Does the HTTP method given support supplying data in the body of the request? For instance this is
 * true for POST but not for GET.
 *
 * @param {string} method The HTTP method that you are processing (e.g. "GET", "POST", etc) 
 * @returns {boolean}
 */
function supportsBody(method) {
    return method === 'POST' || method === 'PUT' || method === 'PATCH';
}

/**
 * Removes all leading/trailing slashes from the given URL segment.
 *
 * @param {string} value The URL path segment to clean up.
 * @returns {string}
 */
function trimSlashes(value) {
    if (!value) {
        return "";
    }
    while (value.startsWith("/")) {
        value = value.substring(1);
    }
    while (value.endsWith("/")) {
        value = value.substring(0, value.length - 1);
    }
    return value;
}

{{ range .Models }}
/** {{ range .Documentation }}
 * {{ . }}{{ end }}
 * @typedef { {{ .Type.JSONType }} } {{ .Name }}{{ range .Fields }}
 * @property { {{ .Type.JSONType }} } {{ .Name }}{{ end }}
 */
{{ end }}

module.exports = {
    {{ range .Services }}{{ .Name }}Client,{{ end }}
};
`)
